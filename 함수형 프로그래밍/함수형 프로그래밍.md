# 함수형 프로그래밍

## 개념

> 자료 처리를 [수학적 함수](https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98)의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 [프로그래밍 패러다임](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84)의 하나이다.
(위키백과)
>

여기에서 수학적 함수는 “동일한 입력을 넣었을 때, 항상 동일한 결과가 반환되는 함수”를 의미한다. 이를 `순수함수` 라고한다.

순수함수는 다음 조건을 만족해야한다.

1. 동일 입력 → 동일 출력
2. No Side Effects
    - 함수 실행이 외부 환경을 변경하는 부작용(side effects)이 있어서는 안된다.
    - ex) 파일 쓰기/읽기, 전역 변수 변경

이러한 순수함수를 사용하면, 출력값이 입력된 값에만 의존하고 그외의 side effects는 존재하지 않으므로, 함수를 이해하고 결과를 예측하기가 쉬워진다.

## 함수형 프로그래밍의 목적

### 순수 함수만으로는 프로그램을 구현하기 어렵다

이메일 전송을 처리하는 프로그램을 만든다고 생각해보자.

함수형 프로그래밍방식으로 구현하기 위해서 `순수함수` 를 사용하여 구현할 것이다. 하지만 `이메일을 전송`하는 것은 side effects를 발생시키므로 순수함수로 구현이 불가능하다.

이처럼 실제 프로그램에서는 side effects를 발생시키는 로직이 필수적이다.

**`함수형 프로그래밍의 목적`**은 순수 함수만으로 코드를 작성하는 것이 아니다. 진정한 목적은 순수함수와 아닌 함수의 경계를 확실하게 나누어 관리하기 위함이다. 이처럼 구분하여 관리 하면, 테스트가 쉽고 멀티 스레드 환경에서도 쉽게 문제를 파악할 수 있다.

### 사용예시

```java
public int applyDiscountAndSaveToDB(Order order) {
    int discount = order.getPrice() * 10 / 100;
    order.setPrice(order.getPrice() - discount);
    orderRepository.save(order); // DB 저장
    return order.getPrice();
}
```

위 함수에서는 동일한 입력을 넣었을 때, 항상 동일한 값이 반환된다. 하지만 save()를 통해 외부 DB에 데이터를 저장하므로 순수함수라고 보기에는 어렵다.

```java
// 순수함수
public int calculateDiscountedPrice(Order order) {
    return order.getPrice() - (order.getPrice() * 10 / 100);
}

// 불순한 영역
public void applyAndSave(Order order) {
    int discounted = calculateDiscountedPrice(order); // 계산은 순수하게
    order.setPrice(discounted); // 변경은 여기서
    orderRepository.save(order); // I/O는 경계에서만
}
```

이전 함수를 순수함수로 변형한 것이다.

이전같은 경우에는 계산 부분만 별도 테스트가 불가능 했는데, 이렇게 나누면 I/O 영역은 Mock방식으로 테스트하고, 순수함수 영역은 값만 넣으면 되므로 이전보다 테스트가 훨씬 쉬워진다.

---

## 앞서서

「쏙쏙 들어오는 함수형 코딩」이라는 책을 참고하여 함수형 프로그래밍에 대해서 공부한 내용을 정리하였다.

# 

## 코드를 나누는 기준

이 책에서 함수형 프로그래밍을 위해 모든 객체(데이터)를 3가지로 구분하였다.

1. 액션 : 순수하지 않은 함수(실행 시마다 변화하는 함수 (side effects))
   ex : 이메일 보내기, DB 읽기
2. 계산 : 순수 함수 (실행 되어도 다른 곳에 영향을 주지 않음)
   ex : 최댓값 찾기, 이메일 형식 검사하기
3. 데이터 : 단순 데이터
   ex : 이메일 주소, 사용자 정보

앞으로 순수함수를 `계산` , 비순수함수를 `액션` 이라고 칭하여 말한다.

## 실제로 적용해보기

구독자에게 이메일로 쿠폰을 보내는 로직을 구현해보면서 이를 적용해보자.

요구사항은 아래와 같다.

1. A등급의 구독자에게는 Best 쿠폰을 전달한다.
2. B등급의 구독자에게는 Good 쿠폰을 전달한다.

이를 실제 함수형 프로그래밍으로 `액션`, `순순함수`, `데이터` 로 구분해나가면서 구현해보자. 순서는 다음과 같다.

1. DB에서 구독자 정보 가져오기
2. DB에서 쿠폰 정보 가져오기
3. 구독자 등급에 따라 이메일로 전송할 쿠폰 데이터 붙이기
4. 이메일 보내기

함수형 프로그래밍의 목적은 순수함수를 구분하여 테스트가 용이하도록 만드는 것이다. 따라서 가능하면 순수함수(계산)만 별도 함수로 분리하여 구현해보자.

1. 구독자의 정보를 DB에서 가져오는 것은 실행 시점에 따라 달라지므로 액션이다.
2. 마찬가지
3. 단순 등급을 확인하고, 쿠폰을 붙이는 것이므로 외부 환경에 영향을 끼치지 않고 동일한 입력에 대해 항상 동일한 출력을 보장하므로 `순수함수` 이다.
4. 이메일을 전송하므로 액션(순수하지 않은 함수)이다.

```java
function sendCoupons() {
	let subscribers = fetchSubscribersFormDB();
	let coupons = fetchCouponsFromDB();
	let goodCoupons = selectCouponsByRank(coupons, "good");
	let bestCoupons = selectCouponsByRank(coupons, "best");
	
	let emails = emailsForSubscribers(subscribers, goodCoupons, bestCoupons);
	
	for(let e = 0; e< emils.length; e++) {
		let email = emils[e];
		emailSystem.send(email);
	}
}
```

사실 위와 같이 코드를 작성하는 것이 왜 함수형 프로그래밍인지 이해는 되지만, 크게 와닿지는 않는다.

## 불필요한 액션을 계산으로 변환하기

계산은 정확한 입력과 정확한 출력이 보장되어야한다.

따라서 함수의 인자들만 입력으로 받고, 출력으로 return 값만 전달하는 구조가 되어야한다. 다시말해서 함수 내부에서 인자가 아닌 값(전역변수 등)을 사용해서는 안되고, return이 아닌 출력 (console.log, 전역변수 변경)이 있어서는 안된다.

이 기준에 맞게 액션 코드를 변경해보는 연습을 해보자.

쇼핑몰 서비스를 운영하는데, **카트에 item들을 담**고, 이를 총 **금액에 반영** 함수를 작성해보자.

```java

// 기존 코드
let shopping_cart = [];

// 카트에 item을 담는 코드
function add_item_to_cart(name, price) {
	shopping_cart.push({
		name : name,
		price : price
	});
	
	calc_cart_total();
}
```

위 `add_item_to_cart` 함수에 있는 shopping_cart.push()를 하는 부분은 액션 이라고 볼 수 있다. 이를 별도 함수로 분리하자. 그리고 입력과 출력을 명시해서 계산함수로 바꿔보자.

```jsx
function add_item_to_cart(name, price) {
	add_item(name, price);
	calc_cart_total();
}

function add_item(name, price) {
	shopping_cart.push({  // 외부 입력(전역변수)를 사용함 
		name : name,        // 전역변수에 변경 값을 저장하여 출력함
		price : price
	});
	
	// return 이 명시되어있지 않음.
}
```

이전의 파란 부분을 별도 함수로 추출하였다.

하지만 `add_item` 함수는 인자가 아닌 입력(전역변수 shopping_cart) 가들어오고, 출력이 명시(return)되어있지 않다. 이를 수정하여 암묵적 입력과 암묵적 출력을 없애보자.

암묵적인 입력 없애기

```jsx
function add_item(cart, name, price) {
	cart.push({
		name : name,
		price : price
	})
}
```

전역변수를 인자로 받는 방식으로 명시적 입력으로 변경하였다. 이제 암묵적인 출력도 없애보자.

```jsx
function add_item(cart, name, price) {
  let new_cart = cart.slice(); // 암묵적인 출력을 제거하기 위해서 복사
  new_cart.push({
	  name : name,
	  price : price
  });
  
  return new_cart; // 명시적으로 반환
}

function add_item_to_cart(name, price) {
	shopping_cart = add_item(shopping_cart, name, price);
	calc_cart_total();
}

```

위 코드는 명시적인 입출력만 존재하는 순수함수이다.

이렇게 액션을 계산으로 바꿀 수 있다

## 더 좋은 액션 만들기

책의 이 파트를 읽으면서, 순수함수란 어떤 목적으로 사용하는지를 알게 될 수 있었다. 함수의 재사용성을 엄청나게 늘린 것인데, 코드를 수정해보면서 이해해보자.

이전에 구현했던 add_item()을 분리해서 **더 좋은 설계**를 만들어보자.

```jsx
let shopping_cart = add_item(shopping_cart, name, price); // 호출

function add_item(cart, name, price) {
  let new_cart = cart.slice(); // 암묵적인 출력을 제거하기 위해서 복사
  new_cart.push({
	  name : name,
	  price : price
  });
  
  return new_cart; // 명시적으로 반환
}
```

`add_item` 함수는 cart, name, price 3개에 의존 되어있다. 여기에서 `name` 과 `price`를 하나의 item으로 묶으면 `cart`와 `item` 을 독립적으로 확장시킬 수 있다. 예를 들어서 cart를 리스트에서 Map으로 바꾼다고 할 때, 변경해야할 부분이 적다는 뜻이다.

cart, item(name, price)로 분리해보며 이해해보자.

```jsx
function add_item(cart, item) { // name과 price를 묶어 item으로 관리
	let new_cart = cart.slice();
	new_cart.push(item);// cart를 Map으로 변경 시 push만 바꾸면 된다.
	
	return new_cart;
}

// item을 만드는 함수를 별도로 추가한다.
function make_cart_item(name, price) {
	return {
		name: name,
		price: price
	};
}

let shopping_cart = add_item(shopping_cart, make_cart_item("water", 700));
```

이제 add_item() 함수는 cart와 item에 제약된 함수가 아니다. 일반적으로 배열과 항목을 넘겨도 잘 동작한다.

이를 더 직관적으로 알 수 있게 이름을 변경해보자.

```jsx
// add_item 이었던 것...
function add_element_last(array, element) {
	let new_array = array.slice();
	new_array.push(element);
	return new_array;
}
```

이제 단순히 cart, item을 위해  사용하는 함수가 아니라, 배열에 값을 추가할 때 사용하는 Utility 함수가 되었다.

### 결합도의 변화

변수를 바꾸고 기능을 분리함으로써 변화하는 의존성을 보자.

```jsx
function add_item(cart, name, price) {
  let new_cart = cart.slice();
  new_cart.push({
	  name : name,
	  price : price
  });
```

기존에는  cart와 item(name, price) 2개에 대한 동작을 처리했다.

```jsx
function add_element_last(array, element) {
	let new_array = array.slice();
	new_array.push(element);
	return new_array;
}

function make_cart_item(name, price) {
	return {
		name: name,
		price: price
	};
}
```

그리고 바뀐 이후에는 array(cart)에 대한 동작만을 처리한다. 그리고 item에 대한 동작은 make_cart_item으로 분리하였다.

## 쓰기 작업을 읽기 작업으로 변환하기

이전에 구현했던 함수들처럼 값(shopping_cart) 자체는 불편하게 만들고, 할당을 통해서만 프로그램을 만들어낼 수 있을까? 즉 모든 동작을 불변형으로 만들 수 있을지에 대해서 알아보자.

프로그램의 동작을 크게 3가지로 분류할 수 있다.

- 읽기
- 쓰기
- 읽기 + 쓰기

읽기는 단순하게 데이터를 읽고, 값을 반환하면 되므로 단순 계산(순수함수)로 처리하기 쉽다.

문제는 쓰기인데, 쓰면서 어떻게 값을 불변하게 만들수 있는지에 대해서 알아보자.

### Copy-On-Write

이전 쇼핑카트처럼 불변해야하는 값을 복사하고, 복사된 값에 쓰기를 하는 방식을 `Copy-On-Write` 라고한다.

```jsx
function add_element_last(array, element) {
	let new_array = array.slice();
	new_array.push(element);
	return new_array;
}
```

이러한 Copy-On-Write는 3가지 단계를 거친다.

1. 복사본 만들기
2. 복사본 쓰기
3. 복사본 반환하기

기존 array 배열을 복사하고, 변경하지 않았기 때문에 이는 근본적으로 `읽기` 작업이라고 할 수 있다. 우리는 이전 과정을 통해 쓰기→읽기 로 변환한 것이다.

### 쓰기 → 읽기 변환

다음 코드를 읽기 동작으로 변환해보자.

```jsx
let a = [1,2,3,4];
let b = a.shift();

console.log(b);  // 1
console.log(a);  // [2,3,4]
```

shift는 a를 변경하는 작업이므로 쓰기 작업이라고 할 수 있다. 하지만 우리는 불변성을 유지하기 위해 a를 변경하지 않고, b에 값을 전달하고 싶다.

이를 위해서 복사본을 사용하자.

```jsx
function shift(array) {
	return array.shift();
}
```

arr.shift()값을 사용하고 싶으므로 위와 같이 return 하는 함수를 만든다. 그리고 복사본을 만들어서 복사본을 수정하도록 하자.

```jsx
function shift(array) {
	let array_cpy = array.slice();
	let first = array_cpy.shift();
	return {
		first : first,
		array : array_cpy
	};
}
```

값을 쓰기 함수에서 읽기 함수로 변경했다.

---