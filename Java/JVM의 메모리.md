# `JVM 에서의 메모리`

JVM(Java Virtual Machine)은 Java 프로그램을 실행하는 가상 머신이다. JVM은 기본적으로 `바이트코드`를 실행하는데, 기계어와 프로그래밍 언어 중간에 위치한 언어라고 생각하면 된다.
그래서 C언어와 같이 기계어로 컴파일 시킨 프로그램에 비해 **느리다**. 이러한 성능 저하를 극복하기 위해서 JVM은 `JIT(Just In Time)`로 바이트 코드를 컴파일한 **기계어 코드**를 JVM 내부에 두는데, 이 영역을 **`Code Cache`** 라고 한다.

Java가 바이트코드를 기반으로 JVM위에서 실행되다 보니 Java 프로세스는 TEXT 영역이 존재하지 않는다. "가상 주소 공간은 OS에서 할당하는것이 아니냐?" 라고 물을 수 있겠지만, Java 프로세스는 OS 위에서 작동하는 것이 아니라 JVM위에서 작동하는 것이다. 따라서 JVM 자체에는 OS위에서 작동하여 TEXT영역이 존재하지만, JVM위에서 작동하는 JAVA 프로그램에는 JVM에서 할당하는 가상 주소공간에서 실행된다.



![JVM](https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fi.imgur.com%2F8uh8SPy.png)

" 출처 : https://dev.to/deepu105/visualizing-memory-management-in-jvm-java-kotlin-scala-groovy-clojure-19le


JVM에서는 메모리를 어떻게 할당하고 사용하는지 알아보자.

---

## `JVM의 메모리`

### `힙과 힙이 아닌 영역`
Java는 OS 가상 메모리 공간이 아닌, JVM에서 할당해주는 가상 메모리 공간을 사용한다. 이 공간은 크게 `힙영역`과 `힙이 아닌 영역`으로 나뉜다.
'"스택과 스택이 아닌 영역"과 같이 나눈것 같은데 이게 무슨 의미가 있냐?' 라고 말할 수도 있는데, 그렇게 나눈 이유는 Java에서 `힙`이 굉장히 중요하기 때문이다.

Java는 `GC(Garbage Collector)`가 있다. 힙 영역에 할당되었는데, 실제로는 사용(참조)되지 않는 객체들을 JVM에 자동으로 반환해주는 기능이다.
Heap 영역만을 대상으로 GC를 동작시켜야하므로, OS에서 제공하는 Stack과 Heap이 분리되지 않는 구조에서는 작동될 수 없다. 이와같은 이유로 힙과 힙이 아닌 영역으로 나눈 것이다.

## `힙 영역`

힙 영역은 그 내부에서 `Young generation`과 `Old generation`으로 나뉘게 된다. (이름이 왜 이렇게 유치?하냐면 버클리 스몰토크에서 유래했기 때문인데.., 뭐 그렇다.)

### `**Young Generation**`

새로운 객체를 만들었을 때 할당되는 공간으로 JVM 힙의 앞쪽에 저장된다.

이 공간은 또다시 `EDEN`, `Survivor 0`, `Survivor 1` 로 나뉜다.

`Eden 영역`은 이제 막 생성 된 객체들이 저장되는 곳이다. 에덴이라는 말 그대로 처음 태어난 곳이다.

`Survivor 0` 공간은 Eden 에서 GC에 의해서 수집되지 않고 살아남은 객체를 저장하는 공간이다. 한마디로 승격했다고 볼 수 있다.

여기에서 또다시 살아남는다면 `Survivor 1` 공간으로 이동한다.

### `**Old Generation**`

Survivor 1 공간에서 살아남은 객체들을 저장하는 메모리 공간으로 JVM 힙 뒷쪽에 있다.
이 공간의 객체들은 앞으로도 오래 사용할 것이라고 판단하여 GC 가 드물게 발생한다.
JVM은 이와같은 방식으로 GC 의 속도를 최적화한다.

```
1차 Minor GC:
[Eden] ──살아남은 애들→ [S0]
[S1] ← 비어있음

2차 Minor GC:
[Eden] + [S0] ──살아남은 애들→ [S1]
[S0] ← 비워짐

3차 Minor GC:
[Eden] + [S1] ──살아남은 애들→ [S0]
[S1] ← 비워짐

...

→ 여러 번 반복 후 Old로 이동

```

---
## `힙이 아닌 영역`

GC가 개입하지 않는 영역으로 크게 4가지로 분류된다.

### `Metaspace`
`.class`와 같은 바이트 코드를 저장해 놓는 공간이다.
가상 주소에서의 Text 영역인데, 정확히는 컴파일 되지 않은 Text 메모리공간이라고 생각하면 되겠다.

JVM은 인터프리터 + 컴파일러인 하이브리드 언어이다.
`Metaspace 영역의 바이트 코드`는 인터프리터 방식으로 그때마다 기계어로 번역하여 실행된다.

컴파일러의 특성을 담은 공간은 Code cache 라는 영역이다.

### `Code cache`
JIT(Just-In-Time) 컴파일러가 **자주 사용되는 바이트 코드**들을 기계어로 번역하여 저장시켜놓은 공간이다. 자주 호출되는 메서드(핫스팟)들을 기계어로 번역하여 저장시켜두는데, 메서드 호출 횟수, 통계 등을 기준으로 기계어로 번역해둔다.

가상 주소 공간으로 생각해본다면 TEXT 영역 = Metaspace + Code cache 라고 볼 수 있겠다

### `Thread Stacks`
일반적인 Stack 메모리 공간이라고 생각하면 된다. 메서드 호출 정보, 지역 변수, 리턴 주소 등이 저장된다.

Java는 멀티 쓰레드를 지원하기 때문에 쓰레드 단위로 독립적인 Stack 메모리 공간을 갖는다. 이를 기반으로 데이터 충돌을 방지할 수 있다.

### `Shared libs`
OS나 프로그램에서 공통적으로 사용하는 함수가 있는 공간이다. 입출력, 쓰게드함수, C표준함수, 수학함수 등이 해당 공간에 저장되어있다.

정확히는 해당 공간에 실제 OS의 가상주소 공간을 참조하는 주소 정보가 들어있어서, JVM이 요청을 받으면 가상 OS 가상주소공간을 참조해서 실행시켜준다.

---

## `GC 작동원리`
간단하게 힙 메모리를 정리하는 GC에 대해 알아보자.

GC는 Young 영역이 찼거나 Old영역이 일정 기준치를 넘었을 때 자동으로 수행된다.

여러 처리방법이 있지만, 대표적인 한가지만 짧게 설명한다.
JVM 힙 영역에 있는 모든 객체들에 대해서 다음을 수행한다.
1. Root 공간부터 순회를 통해 연결된 객체들을 모두 찾아낸다.
2. 연결되어있지 않는 객체들을 Heap 영역에서 제거한다.

DFS/BFS처럼 타고 들어가면서 아예 연결되어있지 않은 객체들을 제거한다고 생각하면 된다.

" 출처 : https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98GC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

GC가 자동으로 힙 영역을 정리할때 Stop-the-world를 발생시켜 처리 지연 및 정지가 발생할 수 있다. 따라서
짧은 시간 지연되는 것에 민감한 서버(금융, 게임 등)를 운영할 때, GC 튜닝이 필수적이다.