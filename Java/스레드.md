# 스레드

# `스레드의 시대`
현대 컴퓨터 기술의 발전으로 스레드가 굉장히 중요해지고 있다. 이 글에서는 왜 우리가 스레드를 처리하는 방법을 알아야하는지를 설명하려고 한다.

## `과거`
과거에는 컴퓨터의 성능을 올리기 위해 **CPU의 성능을 높히는 방법**을 선택했다. 이를 위해서 `**CPU의 클럭 속도(초당 처리량)**`를 높히는 방식으로 발전시켰다.

> 1GHz -> 2GHz -> ...

클럭 속도가 올라가면서 CPU는 동일 시간에 더 많은 명령어를 처리할 수 있게 되었고 이게 컴퓨터의 성능 발전에 큰 영향을 미쳤다.

하지만 **문제**가 발생했다. 발열과 전력소비.
CPU의 클럭속도는 올릴 수 있었지만, 그로인해 발생하는 **발열을 냉각 기술로 감당할 수 없게 되었다.**

여기에서 멈췄다면 우리는 배그 같은 고화질 게임을 실행시키지 못했을 거다. 기술자들은 CPU의 성능을 높히기 위한 다른 방법을 찾아내려고 하였다.

## `멀티 코어`
> 하나의 CPU에서 한계가 발생한다면 CPU를 여러개두어서 처리하면 되는거 아닐까?

바로 멀티코어, 한개의 CPU를 빠르게 만드는것보다 여러개의 CPU를 사용해서 동시에 처리하도록 하는 기술이다.

흔히 intel Core i5의 4코어, 8코어가 CPU의 개수를 의미하는 멀티 코어 구조이다.

그런데 CPU를 단순히 많이 붙인다고 해서 성능이 향상되지 않는 문제가 발생했다.

### `멀티 코어의 문제`
> "CPU가 여러개면 무슨소용이야? 프로그램은 하나의 CPU밖에 사용 못하는데"

여태까지 만들어진 대부분의 프로그램들은 `**단일 스레드**`로 동작하도록 만들어졌기 때문에, 코어의 개수가 프로그램 성능에 영향을 주지 못했던 것이다.

"그냥 단순하게 CPU가 할일을 분배해서 코어로 나누면 되는거 아니야?"

하지만 여기에는 여러 문제가 발생한다. 연산처리의 순서, 자원 공유할 때 발생하는 문제 등으로 인해서 간단하게 처리할 수 있는 문제가 아니었다.

하지만 기술자들은 정말 대단하다. 이를 해결할 방법을 찾아낸 것이다.

## `스레드`

멀티 코어를 잘 활용하기 위해서, 프로그램 내부에 병렬로 처리할 수 있는 여러 작업 흐름인 `**스레드**` 를 만들어냈다. 코어 1개가 하나의 스레드를 담당하고, 여러 코어들이 여러 스레드를 처리하는 방식으로 작동한다.

따라서 우리는 컴퓨터의 성능을 높히기 위해서, 하드웨어 맞게 소프트웨어를 잘 쪼개서 작성할 필요가 있다. 그리고 스레드는 이러한 코어를 잘 활용하여 컴퓨터의 성능을 높힐 수 있는 기술이다.

## `GPU`
GPU는 병렬 처리에 최적화된 하드웨어다. CPU가 소수의 강력한 코어를 갖는다면, GPU는 수천개의 작은 코어들로 명령어들을 처리한다.

따라서 이러한 GPU들도 놀지 않고 잘 사용하기 위해서는 스레드 기반으로 프로그램을 잘 쪼개놓아야한다.

---
# `스레드가 다른 스레드와 자원을 공유하는 방법`

## `멀티스레드 - 자원 공유`

스레드를 사용하는 목적은 명령어를 병렬적으로 빠르게 처리하기 위해서이다. 하지만 다음 단계로 진행하기 위해서는 병렬적으로 처리된 명령들을 다시 가져와서 합치는 과정이 필요할 수 있다.

예를 들어서 커피를 만드는데 다음 과정이 필요하다고 하자.
1. 원두를 간다
2. 물, 컵 등을 준비한다.
3. 원두를 물에내려서 컵에 담는다.

1번과 2번은 병렬적으로 처리할 수 있다. 하지만 3번은 1,2번이 모두 처리된 이후에 처리할 수 있는 명령이다. 따라서 1번 2번은 빠르게 병렬적으로 처리하고, 이 결과를 하나의 스레드로 다시 합치는 과정이 필요하다.

### `스레드간의 자원 공유`
스레드 사이에서는 공유할 때는 대부분 힙 메모리 영역을 사용한다.
스레드는 스택영역들만 독립적 공간으로 사용하기 때문에 힙 영역의 데이터들을 쓰고, 반환하여 자원을 빠르게 공유할 수 있다.

### `IPC - 프로세스간의 자원 공유`
프로세스 내부에서 스레드간의 자원 공유 말고, 프로세스간의 자원 공유는 어떨까?

프로세스는 하나의 가상메모리 공간에서 관리되기 때문에, 내부 스레드 상에서 힙 메모리 접근이 자유로워 공유가 자유롭다. 하지만 프로세스들 사이에서는 독립적으로 분리된 공간을 사용하기 때문에 쉽게 접근하기 어렵다.

이럴때 프로세스 사이에서 데이터를 공유하는 방법이 `IPC(Inter-Process_communication)`이다. **프로세스 간의 통신**을 의미하는데, 대표적으로는 Pipe, Socket, shared Memory, Message queue 방식이 있다.

### `문제점 - 레이스 컨디션`

하지만 동일한 자원에 대해 동시에 접근하여 처리할 경우 예상치 못한 문제가 발생하기도 하는데, 이를 `레이스 컨디션`이라고 한다.

이러한 문제를 해결하기 위해서는 한 스레드(프로세스)가 자원을 사용중일 때 다른 스레드(프로세스)가 사용하지 못하도록 `락`을 거는 방법이 있다.

하지만 무분별한 락 사용은 `데드락`이나 `성능 병목 현상`을 발생시키므로 적절한 사용과 원리를 이해해야한다.


---
# `JVM에서의 멀티 스레드 처리 방식`

Node js는 기본적으로 단일 스레드를 사용하기 때문에 멀티 스레드를 지원하는 JVM을 정리하였다.

## 들어가면서
일반적으로 `스레드 하면 병렬처리하는거` 라고 생각하고 넘어가는 경우가 많다.
하지만 피상적인 이해에만 머물러 있으면 스레드를 잘 활용할 수 없다.
중요한 질문은 다음과 같다.
> "JVM 메모리 구조와 실제 컴퓨터의 CPU 코어는 어떻게 협력하여 병렬처리를 하는가?"
>
> "스레드의 스택, 힙, 그리고 CPU 의 캐시와 레지스터는 어떤 식으로 상호작용하는가?"


메모리 레벨, 더 나아가 CPU 하드웨어 레벨까지 스레드 작동을 이해해보자.

## `스레드는 어디에서 만들어질까?`
JVM의 메모리 구조는 아래와 같다.

![JVM](https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fi.imgur.com%2F8uh8SPy.png)

보면 Heap 이 아닌 영역에 `Thread 영역`이 존재한다. 스레드 영역에 각 스레드가 독립적인 컨텍스트를 갖는다. 그리고 JVM이 스레드에게 다음을 할당한다.

- 고유한 Thread Stack
- 고유한 PC (Program Counter)
- 고유한 Native Stack

위 요소들은 각 스레드 자신만의 공간에 저장되고 **다른 스레드와 절대로 공유되지 않는다.**

## `스레드와 코어`
메모리 영역은 이해가 됐으니, 이제 실제 **하드웨어에서 어떻게 실행**되는지를 이해해보자.

JVM 위의 스레드는 실제 OS 스케쥴러에 의해서 `CPU 코어에 맵핑`된다.
이때 각 CPU 코어는 한번에 1개의 스레드만 실행한다.
따라서 멀티 코어에서는 코어의 개수 만큼의 스레드가 동시에 실행될 수 있는 것이다.

하지만 **스레드의 수가 코어의 수보다 많을 수도 있다.**
이 경우, 현재 코어에서 실행 중인 스레드 정보를 메모리에 저장시키고, 다른 스레드를 불러온다.
이를 `Context Switch`라고 한다. 이를 통해 여러 스레드를 처리할 수 있다.

## `공유 힙과 캐시 문제점`
메모리에서의 힙은 여러 스레드가 같이 사용하는 공간이다. 이로 인해서 `일관성 문제`가 발생할 수 있다.
각 CPU 코어에는 외부 데이터를 더욱 빠르게 접근하기 위해서 임시로 저장하는 캐시가 존재한다.
A 스레드에서 객체 `obj` 필드값을 변경하였다면, 이 변경된 값은 A 코어 캐시에 저장되어있을 가능성이 높다.
하지만 이 시점에서 B가 `obj`필드값에 접근한다면, B는 A에 의해 변경되지 않는 예전의 값을 가져오게 된다.
이를 **캐시 일관성 문제**라고 한다.

이를 해결하기 위해서 JVM은 `synchronized`, `volatile`, `Atomic` 클래스와 같은 동기화 수단을 사용한다. 그리고 CPU 하드웨어 수준에서는 MESI 프로토콜 등을 사용하여 동기화한다.