# 객체지향 프로그래밍

## `절차 지향의 문제점`

객체지향 프로그래밍/패러다임을 이해하기 위해서는 왜 이 패러다임이 나오게 되었는지를 이해할 필요가 있다. 이전 프로그래밍의 패러다임은 `절차지향` 이다. 절차 지향이란, Process(처리과정)에 중심을 두고 코드를 구현한 것을 말한다. 절차 지향 프로그래밍 방식은 `좋은 코드`의 조건을 만족시키기 어렵다.

(로버트마틴 피셜...) 좋은 코드란 다음 3가지를 만족하는 것이라고 한다.
1. 기능이 제대로 구현된 코드
2. 이해하기 쉬운 코드
3. 변경이 용이한 코드

하지만 절차 지향 방식은 위 3개중 2개에서 문제가 있다.

- 이해하기가 어렵다
- 변경하기 어렵다

절차 지향의 위 2가지 문제를 극복하기 위한 해결책으로 `객체 지향 프로그래밍` 이 등장하였다.

---

## `이해하기 쉬운 코드`

프로그래밍에서 이해하기 쉬운 코드는 다음 2가지 관점에 부합하는 것이라고 한다.

1. 일상적인 상식에서 크게 벗어나지 않는 코드
2. 복잡하지 않아서, 기억하기 쉬운 코드

사실 절차 지향코드도 `1번`은 쉽게 만족시킬 수 있다. 문제는 과도하게 이에 맞춘다는 문제가 있다고 할까?

위를 이해하기 위해서 한가지 예시를 들어보도록 하자.

“사람이 가방에서 돈 1만원 꺼낸다.” 이를 구현하면 다음과 같이 구현할 수 있다.
```java
class 사람 {
	private Bag bag;

	돈_꺼내기() {
		// 돈 확인하고
		int money = this.bag.getMoney();
		
		// 액수 있으면 
		if (money > 10000) {
			// 1만원 꺼내기
		} else {
			// 없으면 안꺼내기
		}
	}
}

class Bag {
	private int money;

	getMoney() {...}

	돈빼기(액수) {...}
}

```

일상적인 상식에서 벗어나지 않는다는 것은 ‘`사람`이 `가방` 에 있는 돈을 확인 한 후, 1만원을 꺼낸다’라고 말할 수 있다. 즉, 우리가 실제로 돈을 꺼낼 때 발생하는 프로세스를 그대로 처리한 코드라고 볼 수 있다.

어떻게 보면 이해하기가 정말 쉬운 코드라고 할 수 있다. 사실 이것만 봐서는 뭐가 문제인지도 모르겠다.
하지만 단순하게 위 과정만이 아니라, 여러 과정이 복합적으로 들어가게 되면 이해하기가 굉장히 어려워진다.

위 코드에서 돈이 없으면 카드를 꺼내고, 카드 없으면 수표 꺼내는 행위를 추가해보자.
```java
class 사람 {
	private Bag bag;

	돈_꺼내기() {
		// 돈 확인하고
		int money = this.bag.getMoney();
		
		// 액수 있으면 
		if (money > 10000) {
			// 1만원 꺼내기
		} else {
			// 없으면 안꺼내기
			// 대신 카드 꺼내기
			// ...
			// 카드 없으면 수표 꺼내기...
		}
	}
}
```

여러가지가 복합적으로 들어가면 읽기가 굉장히 복잡해진다.
이러한 기준으로 보았을 때, 절차 지향적인 코드보다는 객체 지향적인 코드가 더욱 이해하기 쉬운 코드가 될 수 있다.

---

## `객체 지향을 통해 절차 지향 문제 해결하기`

절차 지향적인 코드는 Process 에 중심을 둔 코드이다. 다시말해서, 외부의 데이터들을 가져와서 하나로 묶어 처리하는 방식이라고 할 수 있는데, 실제 예시를 통해 이해해보자.

`가방` 내부에는 money라는 필드가 있다. 그리고 `사람`이 가방에 있는 money를 1만원 꺼내려고 한다.

(단, 돈이 1만원 이상 있을 경우에만 꺼낸다고 가정하자.)

절차 지향적인 코드는 아래와 같다.

```java
class 사람 {
	private Bag bag;
	돈_꺼내기() {
		// 돈 확인하고
		int money = this.bag.getMoney();
		
		// 액수 있으면 
		if (money > 10000) {
			// 1만원 꺼내기
		} else {
			// 없으면 안꺼내기
		}
	}
}
```

사람이 돈을 꺼내는 Process에 집중한 것이다.

`사람 class` 에서 로직을 처리를 하는데, `Bag class` 의 money 데이터를 처리하고 있다. Process 적으로는 전혀 이상할게 없다. 사람이 가방에서 돈을 꺼내는게 뭐가 이상할까?

하지만 위와같은 방식은 가독성이 떨어지고, 코드를 변경하기 어렵게 만드는 결과를 만든다.

이를 객체 지향적으로 바꿔보면 다음처럼 바꿀 수 있다.

```java
class 사람 {
	private Bag bag;
	getMoney() {
		bag.getMoney()
	}
}

class Bag {
	int money;
	int getMoney() {
			// 가방에서 돈을 꺼낸다.
		// if (꺼낸 돈이 5만원 이상) {
			// 가방에 있는 돈 1만원을 뺀다.
			// 사람에게 돈 1만원을 추가한다.
		//}
		// else 
			// 아무일도 일어나지 않는다.
	}
}
```

사람의 Process에 중심을 두지 않고, Bag으로 책임을 전가했다. `사람 class` 내부에서는 단순하게 Bag의 구조를 알 필요없이, getMoney() 만 호출하여 처리하면 된다. `Bag class` 에 있는 money 필드를 Bag에 처리하도록 변경한 것이다. 이처럼 내부 데이터를 외부에서 처리하지 않고 감추어 처리하는 것을 `캡슐화` 하였다고 말한다.

### 캡슐화

캡슐화의 목적은 결합성을 낮추는 것이다. 기능을 구현할 때, 외부에서 해당 필드에 접근하여 처리하는 것이 아니라, 해당 필드를 담당하는 class에서 기능을 처리하고 외부에서는 메서드와 같은 하나의 통로로 처리하는 것이다.

### 변경하기 왜 쉽지?

기존 절차지향 방식에서  `사람 class` 의 처리 방식을 변경했다고 생각해보자. 해당 처리가 `Bag class` 와 연관되어있기 때문에, 그 구조를 확인해가면서 수정을 해야한다. 또한, `Bag class` 에서 money 등의 필드값을 바꾼다 하더라도 `사람 class` 또한 이에 맞게 처리를 해야한다.

따라서 Bag 내부 데이터를 모두 `Bag class` 로 옮겨서 처리를 하는 객체 지향 방식을 사용한다면, 위와같은 불편함을 해소 할 수 있을 것이다.

## 객체지향 프로그래밍(OOP) 팁

> 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식

위의 가방의 money를 처리하기 위해서 처리 기능을 가방으로 옮겼다. 이처럼 프로세스와 데이터를 하나의 모듈에서 처리하도록 만들자.

> 의인화

객체지향적인 프로그래밍을 하기위한 좋은 방법은 객체를 살아있는 생명체처럼 다루는 것이다. 그냥 살아있는게 아니라, 자신의 책임을 갖고 자율적인 의사를 갖는 생명체로 다루는 것.

위에서 좋은 코드란, `일상적인 상식에서 크게 벗어나지 않는 코드`라고 했는데, 무생물을 생명체로 다루는게 이상하게 느껴질지도 모르겠다. 여기서 자율성과 책임을 갖는다는 것은 다음과 같다.
```java
class Bag {
	int money;
	void giveToMoney() {
			// 가방에서 돈을 꺼낸다.
		// if (꺼낸 돈이 5만원 이상) {
			// 가방에 있는 돈 1만원을 뺀다.
			// 사람에게 돈 1만원을 준다
		//}
		// else 
			// 아무일도 일어나지 않는다.
	}
}
```
이전 코드에서 약간 말을 수정했다.
`사람에게 돈 1만원을 준다`

사실 가방은 의지가 없으므로 사람에게 돈을 줄 수 없다.
하지만 현실에서는 수동적인 존재일지라도, 일단 객체지향 방식으로 구현하려면 능동적이고 자율적인 존재로 생각하고 구현할 필요가 있다. 이를 `의인화` 라고 한다.


> 출처 : 「오브젝트」
