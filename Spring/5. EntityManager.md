# 5. EntityManager

Hibernate 프레임워크에서 가장 중요한 역할을 하는 클래스다.
데이터를 처리하는 메서드와 영속성 컨텍스트 기능을 제공한다. 
다른말로하면 DB에서 Entity 객체를 처리하는 기능과 캐시 기능을 제공한다.

이에 대해서 알아보자.

## 사용
EntityManager는 Spring에서 자동으로 Bean 객체를 생성하여
컨테이너에 저장한다.

따라서 EntityManager를 사용하고 싶으면 그냥 주입시켜서 사용하면 된다.
```java
@Autowired
private final EntityManager em;
```
생성자로 주입시켜도 된다.

하지만 Spring Data JPA 에서 사용하는 JpaRepository에서는 
모든 처리 과정에서 EntityManager를 사용한다.

save(), delete(), find...() 같은 메서드 내부에서 EntityManager를 호출하기 때문에
사실상 JapRepository는 EntityManager와 떼려고 해도야 뗄수없는 그런 관계다.


## `영속성 컨텍스트란`

원래의 `EntityManager`에서는 `remove()`를 호출할 경우에 바로 delete SQL 문이 날라간다.
즉, remove()와 SQL 쿼리의 실행이 동기화되어서 처리된다.

하지만 JPA/Hibernate 에서는 다른 방식으로 작동한다.
`remove()`를 실행하면 바로 SQL 쿼리가 발생하는 것이 아니라,
영속성 컨테이너에서 먼저 삭제가 되고 이후에 delete SQL문이 날라간다.
이것을 영속성 컨테이너의 `지연쓰기`라고 한다.

```scss
+---------+        +-------------------+        +---------------+
|   DB    | <--->  | 영속성 컨테이너(PC)|  <---> | EntityManager |
+---------+        +-------------------+        +---------------+

```

위와같은 구조를 통해서 데이터를 처리한다. 


영속성 컨텍스트는 Entity 객체들을 모아놓은 집합을 말하는데, 캐시같은 거라고 생각하면 된다.
DB에서 매번 데이터를 꺼내오거나, 바로 동기적으로 쿼리를 날리는 것이
많은 비용이 들어가기 때문에 `영속성 컨텍스트`를 통해 모아뒀다가 한번에 쿼리를 날리는 용도이다.


### `영속성 컨텍스트 기능`
`EntityManager`는 위 영속성 컨텍스트를 사용할 수 있는 기능을 제공한다.
- 영속성 컨텍스트의 생명주기 관리 메서드
  - persist()
  - remove()
  - flush()
  - getReference()


참고로 EntityManager는 `멀티 스레드`에 안전하지 않다.
따라서 스레드 마다 객체를 생성해야한다. 
SpringBoot에서는 자동으로 생성해주니 걱정말고 그냥 주입받자. 

DB에 Entity를 저장시킬 때에는 `Connection 객체`를 사용하여 쿼리를 실행시킨다.


### `영속성 컨텍스트의 객체 상태`
영속성 컨텍스트는 4가지 상태로 객체를 관리한다. 그리고 이 상태에 맞게 (INSERT, UPDATE, SELECT, DELETE) 등의 SQL쿼리를 날린다.
- 비영속 상태
- 영속 상태
- 준영속 상태
- 삭제 상태

각각의 상태에 대해서 구체적으로 알아보자.


### `비영속 상태`
엔티티 객체가 영속성 컨텍스트에 포함되지 않는 상태. 단순하게 new 로 생성한 객체가 비영속 상태라고 보면 된다.
비영속 상태 객체는 `persist()`를 이용하여 영속상태로 관리할 수 있다. (단 @Entity 객체만 가능함)
  
### `영속 상태`
엔티티 객체가 영속성 컨텍스트에 포함되어 관리되고 있는 상태
2가지 방법으로만 영속상태로 만들 수 있다.

```java
MyEntity myEntity1 = entityManager.persist(new MyEntity());
MyEntity myEntity2 = entityManager.find(MyEntity.class, 1L);
```

1. persist()
2. find() - DB에서 데이터를 가져오는 경우

이렇게 영속상태로 만들어낸 객체들은 save()를 통해 DB에 저장시킬 수 있다. 
정확히는 DB에 저장시키는 것이 아니고 `영속성 컨텍스트에 저장`시키는 것이다!

이때 어떤 과정을 거쳐서 영속 상태로 만들어내는지를 알아보자.

```java
@Transactional
@Override
public <S extends T> S save(S entity) {
    if (entityInformation.isNew(entity)) {
        em.persist(entity);
        return entity;
    } else {
        return em.merge(entity);
    }
}
```
위는 save() 코드이다.
isNew()를 통해 해당 entity가 새로 생성된 객체인지(비영속 상태인지 확인) 확인한다.
- 새로 생성된 객체라면 영속상태로 전환시킨다.
- DB에 있는 객체라면 해당 데이터를 `merge()`로 불러와서 영속성 컨텍스트에 저장한다.

이후 영속성 컨텍스트에 저장되어있는 값들을 `flush()`를 통해 DB에 반영한다.
영속성 컨텍스트 객체들을 대상으로 새로운 객체면 INSERT를 처리하고, 수정한 객체는 UPDATE 쿼리를 사용하여 
DB에 데이터를 저장시킨다.

#### `flush 호출 시점`
JPA/Hibernate에서는 자동적으로 flush()를 실행한다.
- 트랜잭션을 종료하기 직전
- flush() 호출 시점

이 flush()가 실행되면 쿼리가 날라가면서 DB에 데이터가 저장된다.


### `준영속 상태`
엔티티 객체가 영속성 컨텍스트에 포함되었다가 분리된 상태. 비영속은 처음부터 안들어가 있는거고 준영속은 있었다가 뺀 것.

한마디로 영속상태의 객체를 영속성 컨텍스트 관리 대상에서 뺀 것이다. 
따라서 flush() 를 통해 DB에 값을 저장하거나 갱신시킬 수 없다.

크게 3가지 메서드를 이용해서 준영속상태로 만들 수 있다.
- detach(Object) : Object를 준영속 상태로 변경한다. 
- clear() : 현재 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 변경한다.
- close() : 영속성 컨텍스트를 종료하면서 clear() 시킨다.

```java
MyEntity myEntity = entityManager.find(MyEntity.class, 1L);
entityManager.detach(myEntity); // 준영속 상태로 변경하기
entityManager.merge(myEntity); // 준영속 -> 영속 상태로 변경하기
```
위처럼 관리할 수 있다.

### `삭제 상태`
영속성 컨텍스트에세 삭제된 상태를 의미한다. 관리하지 않는 준영속과는 다르다!!
영속성 컨텍스트에서 삭제를 한 이후 flush()를 하게될 경우 `delete` 쿼리가 발생하여 DB에 해당 데이터를 삭제하기 때문이다.

삭제된 상태의 entity는 `persist()`를 사용하여 다시 영속상태의 객체로 만들 수 있다.

다음 코드를 보면서 실제로 삭제가 어떻게 처리되는 지 이해해보자.
```java
MyEntity myEntity = entityManager.find(MyEntity.class, 1L); // 불러오기
entityManager.remove(myEntity); // 영속성 컨텍스트에서 삭제하기
entityManager.flush(); // delete 쿼리가 발생한다.
```

```java
public void delete(T entity) {
  //...

  // [1]
  if (entityInformation.isNew(entity)){ 
      return;
  }
  
  Class<?> type = ProxyUtils.getUserClass(entity);

  // [2]
  T existing = (T) em.find(type, entityInformation.getId(entity)); 
  if (existing == null) {
      return;
  }
  
  // [3]
  em.remove(em.contains(entity) ? entity : em.merge(entity));
}
```
위 코드에서 `[1]`은 해당 객체가 새로 생성된 객체인지 확인하는 코드이다. 
새로 생성됐다면 삭제할 필요가 없으니 별 처리를 하지 않는다.

`[2]`는 find()를 사용하여 entity에 해당하는 객체를 DB에서 조회한다. 
만약 조회되지 않으면 어차피 없는 데이터이므로 별 처리를 하지 않고 종료한다.

`[3]`contains() 를 사용하여 영속성 컨텍스트에서 entity 객체가 관리되고 있는지 확인한다.
그리고 관리되고 있지 않다면 merge로 영속성 상태로 변환하고 삭제한다. 
관리되고 있으면 바로 삭제한다.


