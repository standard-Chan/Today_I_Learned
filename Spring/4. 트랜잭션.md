# 4. 트랜잭션

스프링에서는 `@Transcation` 애너테이션을 통해서 트랜잭션을 관리할 수 있다.

여기에서 트랜잭션을 관리한다는 의미는 다음과 같다.
1. 로직 전체를 반영하거나, 아예 반영하지 않도록 만든다
2. 트랜잭션 격리성 레벨을 설정할 수 있다.
3. 트랜잭션 타임아웃을 지정할 수 있다.
4. 읽기 전용 / 쓰기 전용 을 지정할 수 있다.

스프링 부트 트랜잭션에 대해 알아보도록 하자.

## 트랜잭션 애노테이션 뜯어보기
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Reflective
public @interface Transactional {
    Propagation propagation() default Propagation.REQUIRED; // 1

    Isolation isolation() default Isolation.DEFAULT; // 2

    int timeout() default -1; // 3

    boolean readOnly() default false; // 4

    Class<? extends Throwable>[] rollbackFor() default {};  // 5
    //...
}
```
`적용 대상`
적용 대상을 보면 `ElementType.TYPE, METHOD`이다.
클래스와 메서드에 애너테이션을 사용할 수 있다. 클래스에 사용하는 경우 클래스 내부의 모든 메서드가
트랜잭션 대상이 된다.

1. Propagation
   전파의 정도를 지정할 수 있다. 전파란 트랜잭션 메서드 내부에서 또다른 메서드를 호출할 때, 
   해당 메서드를 기존 트랜잭션에 넣을지를 결정하는 것. 짧게 말하자면, 트랜잭션이 전파되는 정도를 지정하는 것이다.
   
2. Isolation
    트랜잭션의 격리성 레벨을 지정한다. 이때, 격리성 레벨의 특성은 연결되어있는 DB의 특성을 따라간다.
    격리성 수준

3. timeout
   트랜잭션 타임아웃 시간을 지정한다.

4. readOnly
   트랜잭션을 읽기 전용으로 시작할지를 결정한다.

5. rollbackFor
   rollback 대상 예외를 지정할 수 있다. 
    기본값은 `unchecked Excetpion`이다.

## 어떻게 작동하는가?
트랜잭션은 AOP 프록시 객체를 통해서 실행된다. 프록시 객체가 실행 메서드를 가로채서 메서드 로직 전/후에 새로운 코드를 작성해서 넣는다.
이를 advice라고 한다. 

다음 내용을 통해 더 자세히 이해해보자.

### AOP 프록시 객체
스프링 부트는 객체를 Bean으로 저장할 때, `AOP 프록시 객체 형태`로 저장한다.
모든 객체를 AOP로 저장하는 것은 아니고, AOP로 만들 필요가 있는 객체들을 프록시로 저장한다.
(@Transactional 붙어있으면 AOP 대상이라고 판단한다)

따라서 `@Transactional`가 있는 메서드의 경우 메서드를 직접 호출하는 것이 아니다.
우리 해당 메서드를 호출하면, Proxy 객체가 해당 메서드를 가로채서 실행 전후에 `Advice`라는 공통 기능을 
자동으로 실행시킨다. 여기에서 공통 기능은 `트랜잭션 시작 코드`, `예외 발생시에 rollback 코드`, `전체 성공시에 commit 코드`가 되겠다.

실제 코드가 어떤 형식으로 생겼는지 이해하면 더욱 쉬울것이다.

### advice 코드 예시
예시를 통해 이해해보자.
아래는 스프링 프레임워크의 TrsnactionInterceptor 객체를 간단하게 표현한 것이다. 
```
// Proxy TransactionInterceptor.class

Transaction Start

try {
    로직처리 (객체.save())   <- 이부분에 가로챈 메서드를 넣는다.
    Transaction commit
} catch (Throwable ex) {
    Trnsaction rollback
    throw ex;
} filnally {
    커넥션 정리
}
```
트랜잭션 시작을 명령으로 DB에 트랜잭션 시작을 알린다. 이때 격리성 수준도 같이 전달된다.
트랜잭션으로 지정된 메서드를 성공적으로 처리하였을 대에 Commit 을 하여 DB에 반영한다.
그렇지 않은 경우에는 rollback 요청을 DB에 전달한다. 

위 과정이 끝나면 커넥션을 정리한다.

## 트랜잭션의 Propagation
Spring boot의 전파정도는 꽤 중요하다.

사실 이전까지는 무작정 `@Transactional` 박아버리는 무지성 코딩을 했었는데, 이러한 전파를 잘 이해하고 사용할 필요가 있다.
특히 어디에서부터 어디까지를 하나의 작업 단위로 설정할 것인지, 그리고 그 사이에 내용들을 반영할 것인지 판단하는 것이 중요하니,
무작정 사용하지말고 잘 이해하고 사용하자.

- 기본값(`REQUIRED`)
  현재 트랜잭션이 존재하면 트랜잭션을 그대로 따라가고, 트랜잭션이 없으면 새로운 트랜잭션을 생성한다.
- 그외 많이 사용하는 값
- `REQUIRES_NEW`
    - 항상 새로운 트랜잭션을 시작한다.
- `SUPPORT`
  - 현재 실행중인 트랜잭션이 존재하면 포함시키고, 없으면 트랜잭션 없이 실행한다.


## `격리성 수준`
DB와 격리성 수준이 동일하다.
기본값 또한 DB의 기본값을 따라간다.

- Isolation.DEFAULT
- Isolation.READ_UNCOMMITTED
- Isolation.READ_COMMITTED
- Isolation.REPEATABLE_READ
- Isolation.SERIALIZABLE

설명은 아래 문서를 참고하자.
[트랜잭션과 격리성 레벨.md](../MySQL/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC%20%EA%B2%A9%EB%A6%AC%EC%84%B1%20%EB%A0%88%EB%B2%A8.md)


## `주의사항`

트랜잭션은 AOP 위빙(Advice 적용)을 잘 고려해서 사용해야한다. 개발자가 많이 실수할 수 있는 부분들이 책에 나와있어서 정리한다.

### `public 접근 제어자 메서드에만 사용 가능`
private나 final 등의 접근 제어자로 선언된 메서드는 프록시 객체로 만들 수 없다. 따라서 public 접근 제어자를 사용하자.

### `Spring Bean으로 주입된 객체의 메서드만 사용 가능`
스프링 빈으로 주입된 객체만 AOP가 advice를 적용시킬 수 있다. (이를 어드바이스를 위빙한다고 한다..) 

구현하다보면 `**클래스 내부 자신의 메서드를 참조하는 경우**`가 있는데, 이런 경우 `this.methodA()` 와 같은 방식으로 호출하게 된다.
하지만 이렇게 호출할 경우 프록시 객체를 통해 호출하는 것이 아니고 직접 호출하는 것이기 때문에 `advice`가 적용되지 않는다.

이런 상황에서는 `자기 주입 방식`을 사용하여 Bean을 주입받고, 주입된 객체를 통해서 `methodA()`를 호출해야한다.

그런데 자기자신을 `생성자 주입 방식`을 통해서 Bean 주입을 받게되면 `순환 참조`에러가 발생한다.

```java
@RequiredArgsConstructor
@Service
public class TestService{
    private final TestService self;
}
```
위와 같은 방식은 생성자를 통해 Bean 객체를 생성하는 방식이다.

"Bean 객체를 생성자로 만듦 -> 빈컨텍스트에 저장" 순서. 

즉, Bean 객체를 생성할 때 TestService(TestService testService); 방식으로 생성하기 때문에 미리 testService라는 Bean 객체가 생성되어 있어야한다.
하지만 당연하게도... 생성이 되어있지 않으므로 순환참조 에러가 발생하게 된다.


따라서 `@Autowried`나 명시적인 `appicationContext.getBean()`을 통해 주입받아야한다.
```java
@Service
public class TestService{
    @Autowried
    private TestService self;
}
```
위 방식은, 미리 객체를 만들어 놓고, Bean 객체를 주입하는 방식이다.

1. TestService 객체를 우선 만듦
2. 주입할 Bean 객체를 주입

따라서 위와같은 방식을 사용하자.


### `격리성 레벨은 통일하는 것이 좋다`
매번 격리 수준을 다르게 설정한다면, 디버깅을 할때 문제점을 찾기 어려워지므로, 가능하면 격리 수준을 통일하는 것이 좋다.